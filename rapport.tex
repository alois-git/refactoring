\documentclass[a4paper, 10pt]{article}

\usepackage{listings}
\usepackage{color}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
% Numbers and units
\usepackage[squaren, Gray]{SIunits}
\usepackage{sistyle}
\usepackage[autolanguage]{numprint}
\usepackage{fullpage}
\usepackage[margin=0.7in]{geometry}
\usepackage{multirow}
\usepackage{xparse}
\usepackage{tikz}

\newcommand\si[2]{\numprint[#2]{#1}}
\newcommand\np[1]{\numprint{#1}}

\newcommand\figref[1]{figure~\ref{fig:#1}}

\NewDocumentEnvironment{myfig}{mm}
{\begin{figure}[!ht]\centering}
{\caption{#2}\label{#1}\end{figure}}

\usepackage[Conny]{fncychap}

\usepackage{enumerate}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keywordstyle=\color{blue},       % keyword style
  language=Java,                   % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  columns=flexible,
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\title{Formalizing Refactorings with Graph Transformation.\\
Sous titre.}
\author{Paulus Alois}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Introduction}

Qu'est ce que le refactoring ? le refactoring permet de changer la structure d'un programme en vue de l'améliorer
tout en préservant son comportement. 

Le refactoring est généralement appliqué sur des programmes écrit en language orienté objet. Il permet de déplacer certaines fonctionnalités d'une classe à une autre, de renomer des variables à travers tout un programme, ect. Il est utile pour éviter la répétition de code.

Le refactoring peut être éffectué à la main. Le programmeur va analyser le code et identifier des parties de code à modifier. Il va ensuite apporter les modifications necessaires.
Cette technique est malheureusement assez lente et peu sure, en effet le programmeur peu faire des erreurs et introduire des bugs.

Pour pallier à ces problèmes, des outils de refactoring sont disponibles et permettent d'automatiser les actions comme le renomage d'une variable, le déplacement d'un fonction ect. Tout en garantissant une certaine sécurité.

Ces outils ne sont malheureusement pas parfait. Ils sont pour la plupart spécialisé dans un seul language de programmation et ne garantisent pas à 100 pourcent la préservation du comportement du programme après un refactoring.

Dans le but de pallier à ces manques, cet article va présenter un moyen de représenter le refactoring comme des transformations de graph. Ces transformations seront vérifiables mathématiquement, ce qui garantira la conservation de certaines propriété du programme.

Ainsi nous auront la possibilité de refactorer en étant certain de ne pas altérer les fonctionnalités de notre programme.

\section{Représentation en graph}
Pour représenter un programme et les règles de refactoring nous aurons besoin de plusieurs type de graph.

\subsection{Transparency}
La plupart des outils de refactoring actuels utilisent le abstract syntax tree augmented with extra links pour représenter la structure d'un programme. Pour pouvoir s'integrer au mieux dans ces logiciels, la représentation en graph doit être le plus proche possible de cet représentation.

\subsection{Conciseness}
Pour que le model reste compréhensible il doit être le plus petit possible de ce faite, nous n'incluerons dans le graph uniquement les choses utiles aux propriété du refactoring.

\subsection{Type}


\subsection{Les graph de type}

Specifies les règles que le graph d'un programme doit respecter. Il doit être suffisament générique pour convenir à differents langages orienté object.


typedGraph.img 

\subsubsection{Les differents type de node}


  \begin{tabular}{ | l | l | l | p{5cm} |}
    \hline
    type & description & examples \\ \hline
    C & Class & EXAMPLE   \\ \hline
    M & Signature de méthode & EXAMPLE   \\ \hline
    MD &  Définition d'une méthode & EXAMPLE   \\ \hline
    V &  Variable & EXAMPLE   \\ \hline
    VD &  Définition d'une variable  & EXAMPLE   \\ \hline
    P & Paramètre & EXAMPLE   \\ \hline
    E &  Expression contenue dans une définition de méthode & EXAMPLE   \\ \hline

    \end{tabular}


\subsubsection{Les différents type d'arrêtes}

  \begin{tabular}{ | l | l |  l | l |}
    \hline type & application & description & examples \\ \hline
    l : & M -> MD  V -> VD &  lookup d'une variable ou d'une méthode à sa définition & EXAMPLE \\ \hline 
    i : & C -> C &  héritage d'une classe à une autre de méthode & EXAMPLE   \\ \hline
    m : & VD -> C  MD -> C &   apartenance d'un variable ou d'une méthode à une classe & EXAMPLE   \\ \hline
    t : & V -> C  M -> C &   type d'une variable ou type de retour & EXAMPLE   \\ \hline
    p : & MD -> P  P -> C &   définition d'un paramètre ou de son type  & EXAMPLE   \\ \hline
    e : & E -> M & expression contenue dans une définition de méthode ou dans une expréssion & EXAMPLE   \\ \hline
    a : & E -> {V|P} & accèss à une variable ou à un paramètre & EXAMPLE   \\ \hline
    u : & E -> {V|P} & mise à jour d'une variable ou d'un paramètre & EXAMPLE   \\ \hline
   \end{tabular}

On voit içi toutes les relations possible entre les nodes en fonction de leur type.
On peut aussi observer quelques cardinalité comme le maximum 1 d'une même définition de méthode dans une classe.

Si ces conditions ne sont pas respectées dans un graph, ce graph ne sera pas valide. En d'autre terme, il ne représentera pas un programme doté d'une syntaxe correcte.

Malheureusement toutes les contraintes necessaires ne sont pas représentables à l'aide d'un graph de type.

\begin{enumerate}
\item une classe ne peut pas contenir plusieurs variables avec le même nom
\item une classe ne peut pas contenir plusieurs méthode avec la même signature
\item une expression contenue dans une méthode ne peut pas accéder à des variables contenues dans les descendants de la classe
\item une expression contenue dans une méthode ne peut pas accéder à un paramètre appartenent à une autre méthode.
\end{enumerate}

Ces contraites peuvent être représenter graphiquement mais sont en générale une infinité de représentation graphique.
Pour régler ce problème nous auront besoin des graph expression expliqué ci dessous.

\subsubsection{Les graphiques de programme} Graph typé et labelé (directes) représentant un programme. Il est composé de node reliées entre elle par des arrêtes. Ces nodes et arrêtes prennent les valeurs vu ci dessus dans le graph de type agrémentées de leurs nom ou d'autres attributs.

Definition : G composé d'un ensemble de node labelée et d'edge labelée est un graph formé de 3-tuple(Vg,Eg,nlabg) ou Vg est un ensemble de nodes, nlabg: est une function de nomage de node et Eg est un ensemble
d'arrêtes.

Dans un graph de programme les entité (classes, variables, méthodes et paramètres) sont représentés par des nodes dont le label est une paire composée de son nom et de son type.

Les relations entre ces différentes entités (héritage, appelle de méthodes, appartenance) sont représentées par des arrêtes. 
Ces arrêtes possèdes un label pour permettre de faire la différence entre les arrêtes de même type ayant la même source et la même destination.

programGraph.img

Ce graph représente le programme transport on voit ici toute la structure du programme.

\subsubsection{Les graph d'expression} : Sont des graph donc les labels des arrêtes sont des expressions régulières, ce qui permet de générer un ensemble de graph à partir d'une seule représentation en remplacent les expressions régulières par toutes leurs valeurs possibles.

graphExpRegu.img

Ce graphique illustrent les avantages apportés par les éxpression régulières dans les labels des arrêtes.

Ces graphiques représentent les différentes contraites non représentable sans les graph expression cité plus haut.

\begin{enumerate}
\item wf1.png
\item wf2.png
\item wf3.png
\item wf4.png
\end{enumerate}

\newpage
\section{Exemple avec un programme}

\subsection{Vehicules}

\begin{lstlisting}[frame=single]
public class Vehicule {
	public String name;
	public Person driver;

	public void accelerating(int amount) {

	}

	public void decelerate(int amount) {
	
	}
}

public class Truck extends Vehicule {

}

public class Person {
	public String name;
}

public class ManualCar {
	public int currentGearSpeed;
	
	public void changeGear(int number) {
	}
}

public class Car extends Vehicule {

}

public class AutomaticCar {

}
\end{lstlisting}

\newpage
\section{Refactoring}

\subsection{Preservation du comportement}
La conservation du comportement d'un programme est une chose primordiale lors d'un refactoring. Cela consiste, en simplifiant, que le programme effectuera les mêmes actions avant et après le refactoring. Nous nous concentrerons ici sur trois proprieté :

\begin{itemize}
\item Preservation de l'accès, chaque méthode accédera au moins à toutes les variables qu'elle accédait avant le refactoring
\item Preservation de la mise à jour, chaque methode mettera à jour au moins toutes les variables mise à jour avant le refactoring
\item Preservation de l'appele, chaque methode appelera au moins toutes les méthodes appelées avant le refactoring
\end{itemize}

\subsection{Encapsulate Variable}

Encapsuler une variable dans une classe est une opération souvent éffectué par les programmeurs. 
Elle consiste à rendre une variable public, privée et à ajouter un accesseur public et un setter public pour continuer à pouvoir accéder et à mettre à jour cette variable.

Lors d'un refactoring cela consiste à changer la visibility de la variable, créer deux nouvelles methodes et changer tout les accès et les mise à jour par des appels aux deux méthodes crées.


\subsubsection{Code before}

\begin{lstlisting}[frame=single]
public class Person {
	public String name;
}
\end{lstlisting}

\subsubsection{Code after}

\begin{lstlisting}[frame=single]
public class Person {
	private String name;
	
	public String GetName(){
		return name;
	}

	public void SetName(String n){
		name=n;
	}
}
\end{lstlisting}

\subsubsection{Condition}

- Il faut que les deux nouvelles méthodes crées ne soit pas déjà présente dans la classe ni dans ses ancêtres et/ou descendants.

WF-1 est préserver car on ne crée ni ne bouge aucune variable.
WF-2 est préserver car la condition stipules qu'ils ne faut pas que des méthodes comportant les même définition que le getter ou le setter soient présente.
WF-3 est préservée car on crée deux méthodes accédant une variable dans la même classe.
WF-4 est préservée car le paramètre de la méthodes setter est employée uniquement dans la définition de cette méthode.

encapsulateVariableConditions.png

\subsubsection{Représentation graphique}

\begin{myfig}{beforeEncapsulateVariable}{Before Encapsulate Variable}
\includegraphics[width=\textwidth]{beforeEncapsulateVariable.png}
\end{myfig}

Dans le haut de la figure~\ref{beforeEncapsulateVariable} se trouve la LHS qui représente la structure d'un sous graph du programme avant sa transformation. A droite, nous avons RHS qui représente la structure de ce sous graph après la transformation. Et en dessous nous avons le graphique du programme.

\begin{myfig}{afterEncapsulateVariable}{After Encapsulate Variable}
\includegraphics[width=\textwidth]{afterEncapsulateVariable.png}
\end{myfig}

Ici dans la figure~\ref{afterEncapsulateVariable} nous avons les mêmes éléments au dessus mais la partie inférieur à changer. 
Elle représente le graphique après l'application de la transformation.

Je n'ai laisser que la transformation du sous graph lié à la variable "driver" pour une meilleure visibilité. 

Normalement cette transformation s'applique à tout les sous graphs correspondant ce qui ici correspond à toute les variables membre d'une classe.

\subsection{Pull Up Method}

Cela Consiste à déplacer une méthode présente dans une ou plusieur classes enfant et l'insérer dans la classe parent.

\subsubsection{Code before}
\begin{lstlisting}[frame=single]
public class Vehicule {
	public String name;
	public Person driver;

	public void accelerating(int amount) { 
	}

	public void decelerate(int amount) { 
	}
}

public class Car extends Vehicule {

}

public class ManualCar extends Car {
	public void changeGear(int speed){ 
	}
}
\end{lstlisting}

\subsubsection{Code after}
\begin{lstlisting}[frame=single]
public class Vehicule {
	public String name;
	public Person driver;

	public void accelerating(int amount) {

	}
	public void decelerate(int amount) { 
	}
	
	public void changeGear(int speed){
	}
}

public class Car extends Vehicule {

}

public class ManualCar extends Car {

}
\end{lstlisting}
\subsubsection{Condition}
Les conditions sont:

- La classe parent ne peut pas déjà contenir une méthode ayant le même nom
- Aucune des variables directement accédée ou modifiée par la méthode ne peut être en dehors du scope de la classe parent.

WF-1 est préserver car on ne crée ni ne bougeons aucune variable.
WF-2 est préserver grâce à la précondition qui stipule qu'il ne peut pas se trouver une méthode avec la même signature dans la classe parent.
WF-3 est préservée grâce à la précondition qui stipule que la définition de la méthode bougée ne doit pas accéder à des variables en dehors du scope du parent.
WF-4 est préservée car on ne crée ni ne modifie aucune méthode.

\subsubsection{Représentation graphique}

\begin{myfig}{beforePullUpMethode}{Before PullUp Methode}
\includegraphics[width=\textwidth]{beforePullUpMethode.png}
\end{myfig}

Dans le haut de la figure~\ref{beforePullUpMethode} se trouve la LHS qui représente la structure d'un sous graph du programme avant sa transformation. A droite, nous avons RHS qui représente la structure de ce sous graph après la transformation. Et en dessous nous avons le graphique du programme.

\begin{myfig}{afterPullUpMethod}{After PullUp Methode}
\includegraphics[width=\textwidth]{afterPullUpMethod.png}
\end{myfig}

Dans la figure~\ref{afterPullUpMethod} la partie du dessous à changé et représente le programme après avoir appliqué la transformation en d'autre termes, après avoir
remonté la méthode de la classe ManualCar à Vehicule. Cette méthode est bien supprimée de la classe ManualCar car il n'existe plus de lien
vers celle çi.

\section{Les productions de graph pour exprimer le refatoring}

Pour exprimer un refactoring appliqué à un programme nous allons appliquer des productions de graph sur le graph de programme.

Il reste cependant quelques problèmes:

- Certain type de refactoring modifie une partie, variable, d'un programme ce qui les rend impossible à représenter grâce à une simple production graphique. Il faut donc appliquer plusieurs productions l'une après l'autre dans un ordre spécifique, pour cela nous auront besoin d'un mecanisme de réecriture de graph controllé.

- La representation d'un refactoring devra être sous forme générique et pas spécifique à certains noms de classe ou de methodes du programme sur lequel il est appliqué. Une technique de production de graph avec des paramètres va donc être emloyée.

- Il est possible que certaines arrêtes deviennent orphelines car elle accedait à une variable qui est maintenant uniquement accessible par un getter ou un setter. Ces arrêtes orphlines ne sont normalement pas autorisé dans un graph, mais les éviter serait beaucoup trop complexe. C'est pour cela que l'on emploie un méchanisme "embedding mechanism" qui autorise ces edges orphiles.

\subsection{Définition des règles de transformation de graph}

Pour définir ces règles j'ai préféré utiliser des représentations graphiques.

Quelques notions doivent être définie avant de pouvoir appliquer une production à un graph:

1) G étant un graph, un sous graph de G contient un ensemble de noeud de G et uniquement les arrêtes reliant des noeuds contenu dans ce sous graph. 

2) Quand on applique un mapping sur les noeuds de G, on applique automatiquement un mapping sur les arrêtes reliant ces noeuds.

3) G et K étant des graphs, un occurence de K dans G est très restrictive c'est à dire que que toutes les arrêtes entre les noeuds correspondant doivent exister. 
Voir figure~\ref{sousGraph} 

\tikzstyle{weight} = [font=\small]
\tikzstyle{edge} = [draw,line width=2pt,-,black]
\tikzstyle{vertex}=[circle,fill=black!25,minimum size=10pt,inner sep=0pt]
\begin{myfig}{sousGraph}{Exemple sous graph}
\begin{tikzpicture}[scale=1.8, auto,swap]
    % Draw a 7,11 network
    % First we draw the vertices
    \foreach \pos/\name in {{(0,2)/b}, {(2,2)/c}, {(1,1)/e},
                            {(0,0)/a}, {(2,0)/d}}
        \node[vertex] (\name) at \pos {$\name$};
    % Connect vertices with edges and draw weights
    \foreach \source/ \dest /\weight in {a/b/, c/b/,c/d/,d/a/,
                                         e/c/, b/e/}
        \path[edge] (\source) -- node[weight] {$\weight$} (\dest);

\end{tikzpicture}
\end{myfig}



\begin{myfig}{sousGraph}{Exemple sous graph valide}
\tikzstyle{edge} = [draw,line width=2pt,-,green]
\tikzstyle{vertex}=[circle,fill=green!25,minimum size=10pt,inner sep=0pt]
\begin{tikzpicture}[scale=1.8, auto,swap]
    % Draw a 7,11 network
    % First we draw the vertices
    \foreach \pos/\name in {{(0,2)/b}, {(2,2)/c}, {(1,1)/e}}
        \node[vertex] (\name) at \pos {$\name$};
    % Connect vertices with edges and draw weights
    \foreach \source/ \dest /\weight in {c/b/,
                                         e/c/, b/e/}
        \path[edge] (\source) -- node[weight] {$\weight$} (\dest);
\end{tikzpicture}
\end{myfig}


\begin{myfig}{sousGraph}{Exemple sous graph invalide}
\tikzstyle{edge} = [draw,line width=2pt,-,red]
\tikzstyle{vertex}=[circle,fill=red!25,minimum size=10pt,inner sep=0pt]
\begin{tikzpicture}[scale=1.8, auto,swap]
    % Draw a 7,11 network
    % First we draw the vertices
    \foreach \pos/\name in {{(0,2)/b}, {(2,2)/c}, {(1,1)/e}}
        \node[vertex] (\name) at \pos {$\name$};
    % Connect vertices with edges and draw weights
    \foreach \source/ \dest /\weight in {c/b/, b/e/}
        \path[edge] (\source) -- node[weight] {$\weight$} (\dest);
\end{tikzpicture}
\end{myfig}


\subsubsection{Definition}

La définition mathématique est donnée à la page 15 de l'article "Formalizin Refactorings with Graph Transofrmations"


\subsection{Encapsulate Variable}


\begin{myfig}{LHSRHSEncapsulateVariable}{LHS et RHS}
\includegraphics[width=\textwidth]{LHSRHSEncapsulateVariable.png}
\end{myfig}

\section{Precondition de refactoring}
Pour exprimer les différentes conditions nessecaire à un refactoring, il est plus facile d'utiliser des precondition qui définisse une sous graph ne pouvant pas être présent avant d'appliquer le refactoring.

\subsection{Pull Up Method}

\begin{myfig}{NACPullUpMethod}{NAC}
\includegraphics[width=\textwidth]{NACPullUpMethod.png}
\end{myfig}

La figure~\ref{NACPullUpMethod}, représente la précondition necessaire (négative) pour pouvoir appliquer le refactoring PullUpMethod.
Elle spécifie que aucun ancêtre de la classe ne possède cette méthode.

\section{Préservation du comportement du programme}

Notre but est de prouver que le refactoring n'altére pas le comportement d'un programme. Pour cela nous allons prouvez que certaines propriétés sont preservée après un refactoring. Et plus particulièrement les propriété de types, accès, mise à jour et appelle de méthode.

Pour prouver cela il faut que si une expression existe avant un refactoring, il existe une expression correspondante apres le refatoring. 

Par exemple: Chaque définition de méthode qui met à jour une variable dans le graph de départ, doit mettre à jour cette variable dans le graph résultat.

MD ( e|c ) * a -> V -> VD

\subsection{Préservation du comportement : Encapsulate Variable}

On peut observer ici que la mise à jour de la variable dans une méthode est conservée après le refactoring, la seule différence est que l'on appéle une méthode qui met à jour la variable à la place de
dirrectement mettre à jour la variable. Ce qui a comme résultat que le chemin de la MD jusqu'à la variable devient plus long


\section{Conclusion}


\end{document}
